/*!
 * Copyright 2019 Palantir Technologies, Inc.
 *
 * Licensed under the MIT license. See LICENSE file in the project root for details.
 *
 */
import * as r from "runtypes";
import { Runtype } from "runtypes/lib/runtype";
import { Context } from "./Context";
export declare const RuleEntry: r.Part<{
    options: r.Unknown;
    excludePackages: r.Array<r.String, false>;
    includePackages: r.Array<r.String, false>;
    includeWorkspaceRoot: r.Boolean;
}>;
export declare type RuleEntry = r.Static<typeof RuleEntry>;
export declare const Config: r.Record<{
    rules: r.StringDictionary<r.Union2<r.Part<{
        options: r.Unknown;
        excludePackages: r.Array<r.String, false>;
        includePackages: r.Array<r.String, false>;
        includeWorkspaceRoot: r.Boolean;
    }>, r.Union2<r.Array<r.Part<{
        options: r.Unknown;
        excludePackages: r.Array<r.String, false>;
        includePackages: r.Array<r.String, false>;
        includeWorkspaceRoot: r.Boolean;
    }>, false>, r.Boolean>>>;
}, false>;
export declare type Config = r.Static<typeof Config>;
export declare const RuleModule: r.Record<{
    check: r.Function;
    optionsRuntype: r.Unknown;
}, false>;
export interface RuleModule<T extends Runtype = Runtype> extends r.Static<typeof RuleModule> {
    check: Checker<T>;
    optionsRuntype: T;
}
export interface Options {
    readonly verbose?: boolean;
    readonly fix?: boolean;
    readonly paths?: ReadonlyArray<string>;
}
export declare type Checker<T extends Runtype> = (context: Context, args: r.Static<T>) => void;
export declare type ResolvedRule = RuleModule & RuleEntry;
export interface ResolvedConfig extends Options {
    readonly rules: ReadonlyArray<ResolvedRule>;
}
//# sourceMappingURL=Config.d.ts.map