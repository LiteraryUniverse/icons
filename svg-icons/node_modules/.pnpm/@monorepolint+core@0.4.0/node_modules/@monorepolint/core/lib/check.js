"use strict";
/*!
 * Copyright 2019 Palantir Technologies, Inc.
 *
 * Licensed under the MIT license. See LICENSE file in the project root for details.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const utils_1 = require("@monorepolint/utils");
const minimatch_1 = tslib_1.__importDefault(require("minimatch"));
const path_1 = require("path");
const WorkspaceContext_1 = require("./WorkspaceContext");
function check(resolvedConfig, cwd = process.cwd(), paths) {
    const workspaceDir = utils_1.findWorkspaceDir(cwd);
    if (workspaceDir === undefined) {
        throw new Error(`Unable to find a workspace from ${cwd}`);
    }
    const workspaceContext = new WorkspaceContext_1.WorkspaceContext(workspaceDir, resolvedConfig);
    if (paths !== undefined) {
        const resolvedPaths = paths.map(p => path_1.dirname(path_1.resolve(p)));
        for (const path of resolvedPaths) {
            if (workspaceDir === path) {
                checkPackage(workspaceContext);
            }
            else {
                checkPackage(workspaceContext.createChildContext(path));
            }
        }
    }
    else if (workspaceDir === cwd) {
        checkPackage(workspaceContext);
        for (const packageDir of workspaceContext.getWorkspacePackageDirs()) {
            checkPackage(workspaceContext.createChildContext(packageDir));
        }
    }
    else {
        checkPackage(workspaceContext.createChildContext(cwd));
    }
    return !workspaceContext.failed;
}
exports.check = check;
function checkPackage(context) {
    if (context.resolvedConfig.verbose) {
        // tslint:disable-next-line:no-console
        console.log(`Starting check against ${context.getName()}`);
    }
    for (const ruleConfig of context.resolvedConfig.rules) {
        if (shouldSkipPackage(context, ruleConfig)) {
            continue;
        }
        ruleConfig.optionsRuntype.check(ruleConfig.options);
        ruleConfig.check(context, ruleConfig.options);
    }
    context.finish();
}
/**
 *
 * @internal
 * @param context
 * @param ruleConfig
 */
function shouldSkipPackage(context, ruleConfig) {
    const exclude = (ruleConfig.excludePackages || []).some(a => minimatch_1.default(context.getName(), a));
    const include = ruleConfig.includePackages === undefined
        ? true
        : ruleConfig.includePackages.some(a => minimatch_1.default(context.getName(), a));
    if (context.getWorkspaceContext() === context && !ruleConfig.includeWorkspaceRoot) {
        return true;
    }
    if (exclude || !include) {
        return true;
    }
    return false;
}
exports.shouldSkipPackage = shouldSkipPackage;
//# sourceMappingURL=check.js.map