"use strict";
/*!
 * Copyright 2019 Palantir Technologies, Inc.
 *
 * Licensed under the MIT license. See LICENSE file in the project root for details.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const camelcase_1 = tslib_1.__importDefault(require("camelcase"));
const path = tslib_1.__importStar(require("path"));
const runtypes_1 = require("runtypes");
const tslib_2 = require("tslib");
const Config_1 = require("./Config");
function resolveConfig(config, options, workspaceRootDir) {
    try {
        const rules = [];
        for (let [type, ruleEntries] of Object.entries(config.rules)) {
            if (ruleEntries === false) {
                continue;
            }
            if (!Array.isArray(ruleEntries)) {
                ruleEntries = [ruleEntries === true ? {} : ruleEntries];
            }
            for (const ruleEntry of ruleEntries) {
                rules.push({
                    ...ruleEntry,
                    ...resolveRule(type, workspaceRootDir, ruleEntry),
                });
            }
        }
        return {
            ...options,
            rules,
        };
    }
    catch (err) {
        if (err instanceof runtypes_1.ValidationError) {
            // tslint:disable-next-line:no-console
            console.error(`Failed to parse config for key '${err.key}':`, err.message, err);
        }
        return process.exit(10);
    }
}
exports.resolveConfig = resolveConfig;
function resolveRule(type, workspaceRootDir, ruleEntry) {
    const ruleModule = loadRuleModule(type, workspaceRootDir);
    try {
        ruleModule.optionsRuntype.check(ruleEntry.options);
        const ret = {
            ...ruleModule,
            ...ruleEntry,
        };
        return ret;
    }
    catch (err) {
        if (err instanceof runtypes_1.ValidationError) {
            // tslint:disable:no-console
            console.error(`Failed to validate the configuration for the rule '${type}'`);
            console.group();
            console.error("Recieved:", ruleEntry.options);
            console.error("Error Message:", err.message);
            console.error(err.key);
        }
        return process.exit(10);
    }
}
function loadRuleModule(type, workspaceRootDir) {
    let mod;
    if (type.startsWith(":")) {
        // if the type starts with `:`, its a built in rule so should be imported from `@monorepolint/rules`
        const ruleVariable = camelcase_1.default(type.slice(1));
        // tslint:disable-next-line:no-implicit-dependencies
        mod = require("@monorepolint/rules")[ruleVariable];
    }
    else if (type.startsWith(".")) {
        // if the type starts with `.` then the rule should be a default export from a local file
        mod = tslib_2.__importDefault(require(path.resolve(workspaceRootDir, type))).default;
    }
    else if (type.includes(":")) {
        // if the type includes `:`, then we should import a const rather than default
        const [packageName, ruleVariable] = type.split(":");
        mod = require(packageName)[camelcase_1.default(ruleVariable)];
    }
    else {
        // otherwise just import the default
        mod = tslib_2.__importDefault(require(type)).default;
    }
    try {
        return Config_1.RuleModule.check(mod);
    }
    catch (err) {
        if (err instanceof runtypes_1.ValidationError) {
            // tslint:disable-next-line:no-console
            console.error(`Failed load rule '${type}':`, err.message, err);
        }
        return process.exit(10);
    }
}
//# sourceMappingURL=resolveConfig.js.map